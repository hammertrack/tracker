package message

// MessageRing is a ring buffer that contains values of `V` type and creates a
// circular list of messages, effectively creating a rotating window of length
// `cap`
//
// For example, we may have a MessageRing of 3 messages: ["aa", "bb", "cc"],
// when the cap is exceeded values are overwritten creating a rotating window:
// msg.Append("username", "dd") -> ["bb", "cc", "dd"]
// msg.Append("usernameB", "ee") -> ["cc", "dd", "ee"]
//
// MessageRing doesn't need to be initialized before using its methods
type MessageRing[V any] struct {
	// Contains pointers to the readeable elements (elements that are initialized)
	next, prev *MessageRing[V]
	// Contains the pointers to all the elements, including those which are not
	// initialized. As it may contain elements which are not initialized, using
	// `val` from realNext or realPrev is unsafe since it may reference nil
	// values. For example, when using a nested struct and using `Filter`, `Do`
	// could pass a nil `val` to filter function if the elements are not
	// initialized.
	realNext, realPrev *MessageRing[V]
	val                V
	cap                int
	head               *MessageRing[V]
	headNext           *MessageRing[V]
}

var offset = 0

func (r *MessageRing[V]) Append(val V) *MessageRing[V] {
	// ~   ->   ~   ->   +
	// head    last     next
	next := r.realNext
	next.val = val

	if offset < r.cap-1 {
		next.next = r.head
		next.prev = r
		r.next = next
		r.head.prev = next
	}
	offset++

	// head contains itself for convenience so we don't have to propvide a initial
	// value (otherwise Do() could reference a nil value). So after we set the
	// value for head we just complete the ring with the actual next element
	// if r.head == r {
	// 	log.Printf("entering: %+v", next.val)
	// 	r.realNext = r.headNext
	// }
	return next
}

func (r *MessageRing[V]) Do(fn func(msg *MessageRing[V], index int)) {
	fn(r, 0)
	for prev, i := r.prev, 1; prev != r; prev, i = prev.prev, i+1 {
		fn(prev, i)
	}
}

// Filter iterates over each element calling a `fn func(val V)` with the element
// and returns all elements whose `fn` returned true
func (r *MessageRing[V]) Filter(fn func(val V) bool) []V {
	// resulting slice size is <= cap. We provide it with the max. cap so append()
	// doesn't entail additional allocations
	msgs := make([]V, 0, r.cap)
	r.Do(func(msg *MessageRing[V], _ int) {
		if fn(msg.val) {
			msgs = append(msgs, msg.val)
		}
	})
	return msgs
}

// Values returns the initialized elements in the ring
func (r *MessageRing[V]) Values() []V {
	all := make([]V, 0, r.cap)
	r.Do(func(msg *MessageRing[V], _ int) {
		all = append(all, msg.val)
	})
	return all
}

// All returns the elements in the ring, including those not initialized
func (r *MessageRing[V]) All() []V {
	all := make([]V, r.cap)
	r.Do(func(msg *MessageRing[V], i int) {
		all[i] = msg.val
	})
	return all
}

func New[V any](cap int) *MessageRing[V] {
	head := &MessageRing[V]{cap: cap}
	head.head = head
	head.next = head
	head.prev = head

	last := head
	for i := 1; i < cap; i++ {
		current := &MessageRing[V]{
			head: head,
			cap:  cap,
		}
		last.realNext = current
		current.realPrev = last
		last = current
	}
	head.realPrev = last
	last.realNext = head

	// Store the first element of the chain after head
	// head.headNext = head.realNext
	// Make head point to itself for the first append
	// head.realNext = head
	return head
}
